package com.bookmap.demo.simple.provider;

import com.bookmap.addons.broadcasting.api.view.BroadcasterProvider;
import com.bookmap.addons.broadcasting.implementations.view.BroadcastFactory;
import velox.api.layer1.*;
import velox.api.layer1.annotations.Layer1ApiVersion;
import velox.api.layer1.annotations.Layer1ApiVersionValue;
import velox.api.layer1.annotations.Layer1Attachable;
import velox.api.layer1.annotations.Layer1StrategyName;
import velox.api.layer1.common.ListenableHelper;
import velox.api.layer1.common.helper.ExecutorsHelper;
import velox.api.layer1.data.InstrumentInfo;
import velox.api.layer1.layers.strategies.interfaces.CustomGeneratedEventAliased;
import velox.api.layer1.messages.*;
import velox.gui.StrategyPanel;

import javax.swing.*;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.ZoneOffset;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;

//This addon is a simple example of a data provider via BroadcastingAPI.
//It just sends live events that are calculated by its generators.
//The addon creates a generator for each instrument, then the generators calculate the moving average based on the trades.
@Layer1Attachable
@Layer1StrategyName(SimpleDemoProvider.ADDON_NAME)
@Layer1ApiVersion(Layer1ApiVersionValue.VERSION2)
public class SimpleDemoProvider implements
        Layer1ApiFinishable,
        Layer1ApiAdminAdapter,
        Layer1ApiInstrumentAdapter,
        Layer1CustomPanelsGetter
{

    public static final String ADDON_NAME = "Simple Demo Provider";
    private static final String DISPLAY_EVENT_PATTERN = "Time=%s, Moving Average=%.2f;";
    private static final int NUMBER_OF_ROWS = 30;


    private final Layer1ApiProvider provider;
    private final AtomicBoolean isWorking = new AtomicBoolean(false);
    private final BroadcasterProvider broadcaster;
    private final ExecutorService messageSender = ExecutorsHelper.newSingleThreadExecutor("Simple-Demo-provider-message-sender");
    private final Object generatorsLock = new Object();
    //by alias
    private final Map<String, Generator> generators = new ConcurrentHashMap<>();
    private final Map<String, JTextArea> guiPanel = new ConcurrentHashMap<>();
    private final Map<String, List<String>> events = new ConcurrentHashMap<>();
    private final Map<String, InstrumentInfo> instrumentInfoMap = new ConcurrentHashMap<>();
    private final Map<String, Boolean> generatorLoadedHistoricalData = new ConcurrentHashMap<>();


    public SimpleDemoProvider(Layer1ApiProvider provider) {
        ListenableHelper.addListeners(provider, this);
        this.provider = provider;
        broadcaster = BroadcastFactory.getBroadcasterProvider(provider, ADDON_NAME, this.getClass());
    }


    @Override
    public void onUserMessage(Object data) {
        if (data.getClass() == UserMessageLayersChainCreatedTargeted.class) {
            UserMessageLayersChainCreatedTargeted message = (UserMessageLayersChainCreatedTargeted) data;
            if (message.targetClass == getClass()) {
                isWorking.set(true);
                broadcaster.start();
                messageSender.submit(() -> {
                    provider.sendUserMessage(new Layer1ApiUserMessageReloadStrategyGui());
                });
            }
        }
        if (data instanceof Layer1ApiHistoricalDataLoadedMessage message) {
            removeGenerator(message.alias);
            createGenerator(message.alias);
        }
        if (data instanceof CustomGeneratedEventAliased eventAliased) {
            //Receive the event generated by our generator and send it to the panel and BrAPI.
            if(eventAliased.event instanceof SimpleDemoProviderEvent event) {
                String alias = eventAliased.alias;
                sendEventToGui(alias, event);
                sendEventToBrApi(alias, event);

                Boolean oldState = generatorLoadedHistoricalData.put(alias, true);
                if(oldState != null && !oldState){
                    messageSender.submit(() -> {
                        provider.sendUserMessage(new Layer1ApiUserMessageReloadStrategyGui());
                    });
                }
            }
        }
    }

    private void sendEventToBrApi(String alias, SimpleDemoProviderEvent event){
        Generator generator = generators.get(alias);
        if(generator != null) {
            broadcaster.sendLiveEventToAllConsumers(generator.getGeneratorId(), event);
        }
    }

    private void sendEventToGui(String alias, SimpleDemoProviderEvent event){
        SwingUtilities.invokeLater(() -> {
            List<String> lines = events.computeIfAbsent(alias, s -> new LinkedList<>());

            String time = convertTimeToData(event.getTime());
            double movingAverage = event.getMovingAverage() * instrumentInfoMap.get(alias).pips;

            String text = String.format(DISPLAY_EVENT_PATTERN, time, movingAverage);
            lines.add(text);
            if(lines.size() > NUMBER_OF_ROWS){
                lines.remove(0);
            }

            JTextArea textArea = guiPanel.computeIfAbsent(alias, s -> new JTextArea());
            textArea.setText(String.join("\n", lines));
        });
    }

    private String convertTimeToData(long time){
        Instant instant = Instant.ofEpochSecond(0, time);
        LocalDateTime dateTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);
        LocalTime localTime = dateTime.toLocalTime();
        String result = localTime.toString();
        return result.split("\\.")[0];
    }

    private void createGenerator(String alias) {
        messageSender.submit(() -> {
            synchronized (generatorsLock) {
                if (!generators.containsKey(alias)) {
                    Generator generator = new Generator(alias);
                    generators.put(alias, generator);
                    broadcaster.registerGenerator(generator.getGeneratorId(), Set.of(SimpleDemoProviderEvent.class),
                            null, null, Set.of(alias));

                    generatorLoadedHistoricalData.put(alias, false);
                    provider.sendUserMessage(getGeneratorMessage(true, alias, generator));
                }
            }
        });
    }

    private void removeGenerator(String alias) {
        messageSender.submit(() -> {
            synchronized (generatorsLock) {
                if (generators.containsKey(alias)) {
                    Generator generator = generators.remove(alias);
                    broadcaster.removeGenerator(generator.getGeneratorId());
                    provider.sendUserMessage(getGeneratorMessage(false, alias, generator));
                }
            }
        });
    }

    private void removeAllGenerators(){
        synchronized (generatorsLock) {
            for (Map.Entry<String, Generator> aliasToGenerator : generators.entrySet()) {
                Generator generator = aliasToGenerator.getValue();
                broadcaster.removeGenerator(generator.getGeneratorId());
                provider.sendUserMessage(getGeneratorMessage(false, aliasToGenerator.getKey(), generator));
            }
            generators.clear();
        }
    }

    private Layer1ApiUserMessageAddStrategyUpdateGenerator getGeneratorMessage(boolean isAdd, String alias, Generator generator) {
        return new Layer1ApiUserMessageAddStrategyUpdateGenerator(
                this.getClass(),
                alias,
                isAdd,
                true,
                true,
                generator,
                new GeneratedEventInfo[] {new GeneratedEventInfo(SimpleDemoProviderEvent.class)}
        );
    }

    @Override
    public StrategyPanel[] getCustomGuiFor(String alias, String s1) {
        if(isWorking.get()){
            StrategyPanel panel = new StrategyPanel("Latest live events");

            Boolean loadHisData = generatorLoadedHistoricalData.get(alias);
            if(loadHisData != null && !loadHisData){
                panel.add(new JLabel("Loading historical data...."));
            } else {
                JTextArea textArea = guiPanel.computeIfAbsent(alias, s -> new JTextArea());
                panel.add(textArea);
            }
            return new StrategyPanel[]{panel};
        } else {
            StrategyPanel panel = new StrategyPanel(null);
            panel.add(new JLabel("The add-on is disabled."));
            return new StrategyPanel[]{panel};
        }
    }

    @Override
    public void onInstrumentAdded(String alias, InstrumentInfo instrumentInfo) {
        instrumentInfoMap.put(alias, instrumentInfo);
        createGenerator(alias);
    }

    @Override
    public void onInstrumentRemoved(String alias) {
        instrumentInfoMap.remove(alias);
        removeGenerator(alias);
    }

    @Override
    public void finish() {
        isWorking.set(false);
        broadcaster.finish();
        removeAllGenerators();
        messageSender.shutdown();
    }
}
